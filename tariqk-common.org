#+TITLE: Common Options for Emacs Starter Kit for Tariq Kamal (tariqk)
#+OPTIONS: toc:nil num:nil ^:nil
#+PROPERTY: header-args :results silent :colnames yes

This is part of Tariq Kamal's common emacs configuration, with options that remain true no matter what device he's on.

This is supposed to be used with [[https://github.com/eschulte/emacs24-starter-kit/][The Literate Programming Fork of the Emacs24 Starter Kit]], and called from $hostname.org via the following, somewhere in the top of the file:

#+begin_example
(org-babel-load-file "tariqk-common.org")
#+end_example

* What goes in here
Basically, things that:

- You use on a regular basis.
- Stuff you'd like to see replicated on ALL emacs instances you run, no matter what kind of machine.

* The Settings themselves
Actual settings go here.

+ NOTE :: Please remember that this should be common to /all/ emacs versions you run. This means stuff that run on terminals, stuff that runs on windowing systems, like that.

Before starting, though, perform this action, because =friend.org= invokes the =package= module, and wouldn't you know, it doesn't load up until then, thus causing havoc with =init.el=, I think. Emacs keeps putting in =(package-initialize)=, over and over again, on that machine:

#+begin_src emacs-lisp
  (when (require 'package nil 'noerror)
    (package-initialize))
#+end_src

** Common functions
Functions used on different environments.

*** The transparent window hack
Considering how commonly this function is used across graphical GUIs, and how long the invocation appears, I figure it's best to refactor it and put it here.

#+begin_src emacs-lisp
  (defun *hx-transparent(alpha-level no-focus-alpha-level)
    "Lets you make the window transparent"
    (interactive "nAlpha level (0-100): \nnNo focus alpha level (0-100): ")
    (set-frame-parameter (selected-frame) 'alpha (list alpha-level no-focus-alpha-level))
    (add-to-list 'default-frame-alist `(alpha ,alpha-level)))
#+end_src

*** Compact and uncompact regions (un-fill region)
This was incredibly useful, and it's surprising that Emacs doesn't have this as a default. [[http://ergoemacs.org/emacs/modernization_fill-paragraph.html][Source]].

#+begin_src emacs-lisp
  (defun *hx-compact-uncompact-block ()
    "Remove or add line ending chars on current paragraph.
  This command is similar to a toggle of `fill-paragraph'.
  When there is a text selection, act on the region."
    (interactive)

    ;; This command symbol has a property “'stateIsCompact-p”.
    (let (currentStateIsCompact (bigFillColumnVal most-positive-fixnum) (deactivate-mark nil))

      (save-excursion
        ;; Determine whether the text is currently compact.
        (setq currentStateIsCompact
              (if (eq last-command this-command)
                  (get this-command 'stateIsCompact-p)
                (if (> (- (line-end-position) (line-beginning-position)) fill-column) t nil) ) )

        (if (use-region-p)
            (if currentStateIsCompact
                (fill-region (region-beginning) (region-end))
              (let ((fill-column bigFillColumnVal))
                (fill-region (region-beginning) (region-end))) )
          (if currentStateIsCompact
              (fill-paragraph nil)
            (let ((fill-column bigFillColumnVal))
              (fill-paragraph nil)) ) )

        (put this-command 'stateIsCompact-p (if currentStateIsCompact nil t)) ) ) )
#+end_src
*** Toggle between UPPER-CASE, lower-case and Initial-Case.
More stuff from Xah Lee, which looks really promising. [[http://ergoemacs.org/emacs/modernization_upcase-word.html][Source]].

#+begin_src emacs-lisp
  (defun *hx-toggle-letter-case (φp1 φp2)
    "Toggle the letter case of current word or text selection.
  Always cycle in this order: Init Caps, ALL CAPS, all lower.

  In lisp code, φp1 φp2 are region boundary.
  URL `http://ergoemacs.org/emacs/modernization_upcase-word.html'
  Version 2015-04-09"
    (interactive
     (if (use-region-p)
         (list (region-beginning) (region-end))
       (let ((ξbds (bounds-of-thing-at-point 'word)))
         (list (car ξbds) (cdr ξbds)))))
    (let ((deactivate-mark nil))
      (when (not (eq last-command this-command))
        (put this-command 'state 0))
      (cond
       ((equal 0 (get this-command 'state))
        (upcase-initials-region φp1 φp2)
        (put this-command 'state 1))
       ((equal 1  (get this-command 'state))
        (upcase-region φp1 φp2)
        (put this-command 'state 2))
       ((equal 2 (get this-command 'state))
        (downcase-region φp1 φp2)
        (put this-command 'state 0)))))

  (global-set-key (kbd "s-/") '*hx-toggle-letter-case)
#+end_src
*** Close all parenthesis
From [[http://emacs.stackexchange.com/a/915][this Emacs Stack Exchange answer]]:

#+begin_src emacs-lisp
(defun *hx-close-all-parentheses ()
  (interactive "*")
  (let ((closing nil))
    (save-excursion
      (while (condition-case nil
         (progn
           (backward-up-list)
           (let ((syntax (syntax-after (point))))
             (case (car syntax)
               ((4) (setq closing (cons (cdr syntax) closing)))
               ((7 8) (setq closing (cons (char-after (point)) closing)))))
           t)
           ((scan-error) nil))))
    (apply #'insert (nreverse closing))))
(global-set-key (kbd "C-)") '*hx-close-all-parentheses)
#+end_src
** Backend Stuff
How things work in the background.

*** Package Management Locations
Hey, so here's a thing I /finally/ figured out; it turns out that you /can/ extract lists from tables. With some jiggery-pokery based on [[http://stackoverflow.com/a/19775362][this StackOverflow answer]], you can have a list of repositories, like so:

#+NAME: repository-names
| label        | URI                                       |
|--------------+-------------------------------------------|
| GNU          | http://elpa.gnu.org/packages/             |
| elpy         | http://jorgenschaefer.github.io/packages/ |
| marmalade    | http://marmalade-repo.org/packages/       |
| MELPA        | http://melpa.org/packages/                |
| org          | http://orgmode.org/elpa/                  |
| MELPA-stable | http://stable.melpa.org/packages/         |
| original     | http://tromey.com/elpa/                   |

And then, using this, you can incorporate it, /sort of cleanly/, with this:

#+begin_src emacs-lisp :var label=repository-names[,0] URI=repository-names[,1]
  (when (require 'package nil 'noerror)
    (progn
      (require 'cl) ; This will be sort of awkward if it doesn't exist at this point.
      (setq package-archives (pairlis label URI))
      (package-initialize))) ; reinitialize!
#+end_src

Now you /should/ be able to add, modify and delete repositories cleanly by using the org-tables format.

Or everything would break and you'd have to go back to the last commit, but hey.

*** Settings for package-pinning (common)

Here are the list of packages that /must/ be installed on /all/ Emacs instances I control, along with the apt-pinning preferences.

#+NAME: package-settings
| name               | repository   |
|--------------------+--------------|
| color-theme        | MELPA        |
| dired+             | MELPA        |
| dired-sort-menu    | MELPA        |
| dired-sort-menu+   | MELPA        |
| form-feed          | MELPA-stable |
| htmlize            | MELPA        |
| org-bullets        | MELPA-stable |
| org-plus-contrib   | org          |
| ox-reveal          | MELPA        |
| ox-twbs            | MELPA        |
| paradox            | MELPA-stable |
| powerline          | MELPA-stable |
| rainbow-delimiters | MELPA-stable |
| sx                 | MELPA-stable |
| undo-tree          | MELPA        |
| yasnippet          | MELPA-stable |

And do basically two things: set the package-pinning options, and then install the packages if they don't exist.

The [[http://emacs.stackexchange.com/a/17013/5509][basic solution]] is thanks to [[http://emacs.stackexchange.com/users/3889/xuchunyang][xuchunyang]] from the [[http://emacs.stackexchange.com][Emacs Stack Exchange site]], who provided me with the basic structure and pointed out my initial error in using =make-symbol= instead of =intern=, and to top it off, finished it all of in a =mapcar= and =mapc= structure to transform =name= from a list of strings to a list of symbols, thus eliminating the need to use temporary variables.

Rather than using their suggestion of manually using =package-install=, however, I'm using =starter-kit='s own =starter-kit-install-if-needed= function. It's a little more readable, at any rate, and why repeat oneself?

#+begin_src emacs-lisp :var name=package-settings[,0] repository=package-settings[,1]
  (when (require 'package nil 'noerror)
    (when (require 'cl nil 'noerror)
      (let ((pkgs (mapcar #'intern name)))
        (setq package-pinned-packages (pairlis pkgs repository))
        (apply 'starter-kit-install-if-needed pkgs)
        (package-initialize))))
#+end_src

** Interface
Settings for Emacs user interfaces, which include appearances and custom keybindings.

*** Interface changes that don't need new packages
**** CUA-mode
So I grew up on Windows systems.

While I do get /some/ of the terminology (i.e. C-k means cut everything between the cursor to EOL and put it into the kill-ring, C-y means paste the last entry from the kill-ring onto the document), I use too many Windows tools to allow me to mentally switch gears every time I change machines. So CUA-mode it is.

#+begin_src emacs-lisp
(cua-mode t)
#+end_src

**** =show-paren-mode=: Show Expressions, not just matching brackets.
Oh my GOD. From ErgoEmacs' Xah Lee, [[http://ergoemacs.org/emacs/emacs_editing_lisp.html][this trick]]:

#+BEGIN_SRC emacs-lisp
  (setq show-paren-style 'expression)
#+END_SRC

**** Get rid of the toolbar and menu-bar
Takes up space only. What a waste, especially on the netbook.

#+begin_src emacs-lisp
  (tool-bar-mode -1)
  (menu-bar-mode -1)
#+end_src

**** Visual-line-mode
I can't /stand/ having to muck around with linewraps while I'm writing. It's fucking annoying. So, instead, I shall use visual-line-mode.

Of course, since this annoyance really only comes during writing, and not coding, we shall only put it on in text modes. Sounds fair? Hope so.

#+begin_src emacs-lisp
(add-hook 'text-mode-hook 'turn-on-visual-line-mode)
(remove-hook 'text-mode-hook 'turn-on-auto-fill)
#+end_src

**** Changes to modes related to Emacs Lisp
As defined here, these are the modes that are related to Emacs Lisp:

#+name: emacs-lisp-related-modes
| mode                  |
|-----------------------|
| emacs-lisp-mode       |
| ielm-mode             |
| lisp-interaction-mode |

This table is used in the following manner:

***** Activate =eldoc-mode= and tweak it's behaviour
First, [[http://emacswiki.org/emacs/ElDoc][based on this suggestion]], highlight the =eldoc= arguments in =font-lock-variable-name-face=:

#+begin_src emacs-lisp
  (setq eldoc-argument-case '(lambda (arg)
                               (propertize (upcase arg)
                                           'face 'font-lock-variable-name-face)))
#+end_src

And then, activate =eldoc-mode=:

#+begin_src emacs-lisp :var modes=emacs-lisp-related-modes[,0]
  (when (require 'cl nil 'noerror)
    (lexical-let ((hooks (mapcar (lambda (arg) (intern (concat arg "-hook"))) modes)))
      (dolist (hook hooks)
        (add-hook hook 'turn-on-eldoc-mode))))
#+end_src

***** Define and activate =prettify-symbols-alist=
Really it's for *a e s t h e t i c* reasons, hahaha.

Anyway, because it'd probably be easier for myself, I'll just use the table format and work on it that way, since it's an alist, right? No harm in that.

#+NAME:prettify-table
| token    | code |
|----------+------|
| "not"    |  172 |
| "*"      |  215 |
| "/"      |  247 |
| "lambda" |  955 |
| "->"     | 8594 |
| "map"    | 8614 |
| "/="     | 8800 |
| "<="     | 8804 |
| ">="     | 8805 |

Thanks to [[http://stackoverflow.com/questions/32878675/using-elisp-local-variables-instead-of-global-variables-to-add-a-function-into-a][this conversation on StackOverflow]], I've made significant headway in improving this function, which now works great. As it turns out, Emacs Lisp uses /dynamic binding/, which is something I still am not exactly accustomed to, since I'm more used to /lexical binding/. Thanks to [[http://stackoverflow.com/users/729907/drew][Drew]] for starting me off on that direction.

In any case, [[http://stackoverflow.com/users/324105/phils][phils]]' suggestion to use =cl='s =lexical-let= instead of vanilla =let= works, so that's what I ended up using.

In any case, I've simplified it so significantly now, by having a table containing =emacs-lisp-related-modes= above, and basically running through every emacs-related mode, to both set the code table and activate =prettify-symbols-mode=. I'm liking the end-result.

#+begin_src emacs-lisp :var token=prettify-table[,0] code=prettify-table[,1] mode-name=emacs-lisp-related-modes[,0]
  (when (require 'cl nil 'noerror)
    (lexical-let ((pretty)
                  (hooks (mapcar (lambda (arg) (intern (concat arg "-hook"))) mode-name)))
      (setq pretty (pairlis token code))
      (dolist (hook hooks)
        (add-hook hook (lambda ()
                         (setq prettify-symbols-alist pretty)
                         (prettify-symbols-mode t))))))
#+end_src

*** UX-changing packages
**** =rainbow-delimiters= Mode
Too many parentheses and the like mess me up. Can't have that, hence, rainbow-delimiters-mode.

Here's a list of modes that need =rainbow-delimiters-mode=:

#+name:modes-that-need-rainbow-delimiters
| mode      |
|-----------|
| ielm-mode |
| org-mode  |
| prog-mode |

Load =rainbow-delimiters-mode= for the above modes:

#+begin_src emacs-lisp :var modes=modes-that-need-rainbow-delimiters[,0]
  (when (require 'rainbow-delimiters nil 'noerror)
    (when (require 'cl nil 'noerror)
      (lexical-let ((hooks (mapcar (lambda (arg) (intern (concat arg "-hook"))) modes)))
        (dolist (hook hooks)
          (add-hook hook #'rainbow-delimiters-mode)))))
#+end_src
**** Activate =powerline=
From the =powerline= [[https://github.com/milkypostman/powerline][github page]]:

#+begin_src emacs-lisp
  (when (require 'powerline nil 'noerror)
    (powerline-center-theme))
#+end_src

**** =form-feed-mode= activated where I need it.
Here's a table of modes that need =form-feed-mode=.

#+name:modes-needing-form-feed-mode
| mode             |
|------------------|
| compilation-mode |
| emacs-lisp-mode  |
| help-mode        |

This puts together several tricks I've learned during working on this file:

1. using =lexical-let= to use lexical binding in the section that needs it
2. using =mapcar= to modify the list of items in place:
   * first by using =concat= to add ="-hook"= to the string
   * and then =intern= to turn it into a symbol
3. and then finally using =dolist= to iterate through every item and run the operations necessary

I forsee that this will come very useful in the =prettify-symbols-mode= section.

#+BEGIN_SRC emacs-lisp :var modes=modes-needing-form-feed-mode[,0]
  (when (require 'form-feed nil 'noerror)
    (when (require 'cl nil 'noerror)
      (lexical-let ((hooks (mapcar (lambda (arg) (intern (concat arg "-hook"))) modes)))
        (dolist (hook hooks)
          (add-hook hook #'form-feed-mode)))))
#+END_SRC

**** =undo-tree= mode.
Thanks to recommendations from the esteemable [[http://pages.sachachua.com/.emacs.d/Sacha.html#unnumbered-20][Sacha Chua]] and [[http://pragmaticemacs.com/emacs/advanced-undoredo-with-undo-tree/][Pragmatic Emacs]], I'm installing =undo-tree=, using Sacha's recommended settings and PrEmacs' alias. Rather than use PrEmacs' or Sacha's recommended settings, though, I'm /finally/ unbinding =C-y= and using that for =redo=.

#+begin_src emacs-lisp 
  (when (require 'undo-tree nil 'noerror)
    (progn
      (global-undo-tree-mode 1)
      (setq undo-tree-visualizer-timestamps t)
      (setq undo-tree-visualizer-diff t)
      (defalias 'redo 'undo-tree-redo)
      (global-unset-key (kbd "C-y")) ; Because it's tied to yank now, screw that.
      (global-set-key (kbd "C-y") 'redo)))
#+end_src

**** Activating dired-sort-menu mode
Based on the documentation, load =dired-sort-menu= mode when dired loads.

#+BEGIN_SRC emacs-lisp
  (add-hook 'dired-load-hook
            (lambda () (require 'dired-sort-menu)))
#+END_SRC

*** Changes to =org-mode=
**** Custom org-faces & settings
***** Mucking about with faces
Some tweaks that don't involve color, just size, for org-mode. Also, enable syntax highlighting for blocks in org-mode. Tried that whole "colorize the =begin_src= =end_src= shit, didn't like it. Gave me eyestrain.

#+begin_src emacs-lisp
  (setq org-src-fontify-natively t)
  (custom-set-faces
   '(org-document-title
     ((t (:weight extra-bold :height 1.0)))))
#+end_src

***** Org-mode custom settings
Everything involving the most common settings for org-mode, here in the common file.

#+BEGIN_SRC emacs-lisp
  (custom-set-variables
   ; values that normally go under the #+STARTUP (except where mentioned) header:
   '(org-hide-leading-stars t)              ; hidestars
   '(org-startup-indented t)                ; indent
   '(org-log-done t)                        ; logdone
   '(org-pretty-entities t)                 ; entitiespretty
   '(org-startup-folded 'content)           ; #+STARTUP: content
   '(org-export-with-sub-superscripts nil)  ; #+OPTIONS: ^:{}
   '(org-export-backends (quote (ascii html md ox-twbs ox-reveal))))
#+END_SRC

**** Make =org-bullet= install & load, put it in org-mode
Can't think of a reason why not. Why not?

#+BEGIN_SRC emacs-lisp
  (when (require 'org-bullets nil 'noerror)
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC
**** New =org-structure-template-alist=
Obviously the way I would like to do it is to put in a table, as such:

#+name:shortcuts-alist
| key | value      |
|-----+------------|
| n   | #+NAME:?   |

#+BEGIN_SRC emacs-lisp :var key=shortcuts-alist[,0] value=shortcuts-alist[,1] :results none
(when (require 'org nil 'noerror)
  (when (require 'cl nil 'noerror)
    (lexical-let ((sequences (mapcar* #'list key value))
                  (original))
      (setq original org-structure-template-alist)
      (setq org-structure-template-alist (append original sequences)))))
#+END_SRC
x
**** Add org-presentation mode with =ox-reveal=, using reveal.js served via CDN
So I'm going to use =ox-reveal=, but rather than install =reveal.js= locally by default, I'll use the [[http://cdn.jsdelivr.net/reveal.js/3.0.0/][reveal.js copy available on jsDelivr]], which means that while I may end up being dependent on a network, I'll at least not have to install anything additional.

If necessary, I'll install =reveal.js= where needed, usually in the =#+REVEAL_ROOT= option, as shown [[https://github.com/yjwen/org-reveal#url-form-for-file-location][here]].

#+BEGIN_SRC emacs-lisp
  (when (require 'ox-reveal nil 'noerror)
    (setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0/"))
#+END_SRC

** Activating custom =starter-kit= modules.
I can't believe I never included this in the first place. In any case, activating the =starter-kit= modules that will be used by /all/ variants of Emacs that I use.

#+begin_src emacs-lisp
  (starter-kit-load "org")
  (starter-kit-load "yasnippet")
#+end_src

